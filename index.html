<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Quick Share Memo</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome (Icons) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* モバイルブラウザのツールバーによる高さ変動に対応 */
        :root {
            --sat: env(safe-area-inset-top);
            --sar: env(safe-area-inset-right);
            --sab: env(safe-area-inset-bottom);
            --sal: env(safe-area-inset-left);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            overflow: hidden;
            overscroll-behavior-y: none;
            background-color: #f3f4f6;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-width: 48rem;
            margin-left: auto;
            margin-right: auto;
            background-color: white;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
        }

        /* カスタムスクロールバー */
        textarea::-webkit-scrollbar {
            width: 6px;
        }
        textarea::-webkit-scrollbar-track {
            background: transparent;
        }
        textarea::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 20px;
        }

        /* モーダルアニメーション */
        .modal-overlay {
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease-out;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-box {
            transform: scale(0.95);
            transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .modal-overlay.active .modal-box {
            transform: scale(1);
        }

        /* フッターのセーフエリア対応 */
        .footer-safe {
            padding-bottom: calc(1rem + var(--sab));
        }

        /* 画像プレビューのアニメーション */
        .image-preview-enter {
            animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react/": "https://esm.sh/react@^19.2.4/",
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "lucide-react": "https://esm.sh/lucide-react@^0.563.0"
  }
}
</script>
</head>
<body>

    <div class="app-container">
        <!-- Header -->
        <header class="bg-white border-b border-gray-100 px-4 py-3 flex justify-between items-center z-10 shrink-0 shadow-sm">
            <h1 class="font-bold text-lg text-gray-700 flex items-center gap-2">
                <i class="fa-solid fa-pen-nib text-blue-500 text-xl"></i>
                <span>クイックシェア</span>
            </h1>
            <div class="flex items-center gap-1">
                <button onclick="app.insertTime()" class="text-gray-400 hover:text-blue-500 hover:bg-blue-50 transition-all p-2 rounded-full active:scale-90" title="日時を挿入">
                    <i class="fa-regular fa-clock text-xl"></i>
                </button>
                <button onclick="app.triggerImageSelect()" class="text-gray-400 hover:text-blue-500 hover:bg-blue-50 transition-all p-2 rounded-full active:scale-90" title="画像を挿入">
                    <i class="fa-regular fa-image text-xl"></i>
                </button>
                <div class="w-px h-4 bg-gray-300 mx-1"></div>
                <span id="charCount" class="text-[10px] text-gray-400 font-mono w-14 text-right">0文字</span>
                <button onclick="app.openDeleteModal()" class="text-gray-400 hover:text-red-500 hover:bg-red-50 transition-all p-2 rounded-full ml-1 active:scale-90" title="削除">
                    <i class="fa-solid fa-trash-can text-lg"></i>
                </button>
            </div>
        </header>

        <!-- Main Area -->
        <main class="flex-1 overflow-hidden flex flex-col p-3 pb-1 gap-2 relative">
            <textarea 
                id="memoInput" 
                class="flex-1 w-full p-4 text-[17px] leading-relaxed bg-gray-50/50 rounded-2xl border border-gray-100 focus:border-blue-200 focus:bg-white focus:ring-4 focus:ring-blue-500/5 transition-all resize-none outline-none placeholder-gray-300"
                placeholder="ここに入力して即共有..."
                spellcheck="false"
            ></textarea>
            
            <!-- Image Preview Area -->
            <div id="imagePreviewContainer" class="hidden shrink-0 relative group animate-image-preview-enter">
                <div class="relative rounded-xl overflow-hidden border border-gray-200 bg-gray-50 max-h-48 flex justify-center">
                    <img id="previewImage" src="" alt="添付画像" class="h-full object-contain max-h-48 w-auto">
                    <button onclick="app.removeImage()" class="absolute top-2 right-2 bg-black/50 hover:bg-black/70 text-white rounded-full p-1.5 w-8 h-8 flex items-center justify-center transition-all backdrop-blur-sm">
                        <i class="fa-solid fa-xmark text-sm"></i>
                    </button>
                </div>
            </div>
            
            <!-- Hidden File Input -->
            <input type="file" id="imageInput" accept="image/*" class="hidden" onchange="app.handleImageSelect(event)">
        </main>

        <!-- Footer -->
        <footer class="bg-white border-t border-gray-100 p-4 footer-safe z-10 shrink-0 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
            <div class="grid grid-cols-5 gap-3">
                <button onclick="app.copyToClipboard()" class="col-span-2 bg-gray-100 hover:bg-gray-200 active:bg-gray-300 text-gray-700 font-bold py-3.5 rounded-2xl transition-all flex items-center justify-center gap-2 group active:scale-95">
                    <i class="fa-regular fa-copy group-active:scale-90 transition-transform text-lg"></i>
                    <span>コピー</span>
                </button>
                <button onclick="app.shareContent()" class="col-span-3 bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-3.5 rounded-2xl shadow-lg shadow-blue-200 transition-all flex items-center justify-center gap-2 active:scale-95">
                    <i class="fa-solid fa-paper-plane text-lg"></i>
                    <span>共有する</span>
                </button>
            </div>
        </footer>

        <!-- Delete Confirmation Modal -->
        <div id="deleteModal" class="modal-overlay fixed inset-0 bg-black/50 backdrop-blur-[2px] z-[100] flex items-center justify-center p-6">
            <div class="modal-box bg-white rounded-2xl w-full max-w-xs p-6 shadow-2xl">
                <div class="flex justify-center mb-4">
                    <div class="h-12 w-12 rounded-full bg-red-100 flex items-center justify-center">
                        <i class="fa-solid fa-eraser text-red-600 text-2xl"></i>
                    </div>
                </div>
                <h3 class="text-lg font-bold text-gray-900 text-center mb-2">すべて消去しますか？</h3>
                <p class="text-sm text-gray-500 text-center mb-6 leading-relaxed">テキストと添付画像が削除され、新しいタイムスタンプが挿入されます。</p>
                <div class="flex gap-3">
                    <button onclick="app.closeDeleteModal()" class="flex-1 px-4 py-2.5 bg-gray-100 text-gray-700 rounded-xl font-semibold hover:bg-gray-200 transition-colors active:scale-95">
                        キャンセル
                    </button>
                    <button onclick="app.confirmDelete()" class="flex-1 px-4 py-2.5 bg-red-600 text-white rounded-xl font-semibold hover:bg-red-700 shadow-sm transition-colors active:scale-95">
                        消去して新規
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            STORAGE_KEY: 'quickShareMemo',
            dom: {},
            currentImage: null, // Base64 string

            init() {
                this.dom = {
                    memoInput: document.getElementById('memoInput'),
                    charCount: document.getElementById('charCount'),
                    deleteModal: document.getElementById('deleteModal'),
                    imageInput: document.getElementById('imageInput'),
                    imagePreviewContainer: document.getElementById('imagePreviewContainer'),
                    previewImage: document.getElementById('previewImage')
                };

                this.dom.memoInput.addEventListener('input', () => {
                    this.saveData();
                    this.updateCharCount();
                });

                this.dom.memoInput.addEventListener('paste', (e) => this.handlePaste(e));

                this.dom.deleteModal.addEventListener('click', (e) => {
                    if (e.target === this.dom.deleteModal) this.closeDeleteModal();
                });

                this.loadData();

                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', () => {
                        document.body.style.height = window.visualViewport.height + 'px';
                        if (document.activeElement === this.dom.memoInput) {
                            setTimeout(() => window.scrollTo(0, 0), 100);
                        }
                    });
                }
            },

            getFormattedDate() {
                const now = new Date();
                const days = ['日', '月', '火', '水', '木', '金', '土'];
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const date = String(now.getDate()).padStart(2, '0');
                const day = days[now.getDay()];
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                return `${year}/${month}/${date}(${day}) ${hours}:${minutes}`;
            },

            loadData() {
                const saved = localStorage.getItem(this.STORAGE_KEY);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        if (typeof data === 'object' && data !== null) {
                            this.dom.memoInput.value = data.text || '';
                            if (data.image) {
                                this.setImage(data.image);
                            } else {
                                this.removeImage(false);
                            }
                        } else {
                            this.dom.memoInput.value = saved;
                        }
                    } catch (e) {
                        this.dom.memoInput.value = saved;
                    }
                } else {
                    this.resetWithTimestamp(false);
                }
                this.updateCharCount();
            },

            saveData() {
                const data = {
                    text: this.dom.memoInput.value,
                    image: this.currentImage
                };
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.error('Storage full?', e);
                }
            },

            updateCharCount() {
                const count = this.dom.memoInput.value.length;
                this.dom.charCount.textContent = count + '文字';
            },

            resetWithTimestamp(shouldFocus = true) {
                const timestamp = this.getFormattedDate();
                const newText = timestamp + '\n';
                this.dom.memoInput.value = newText;
                this.removeImage(false);
                
                this.saveData();
                this.updateCharCount();
                
                if (shouldFocus) {
                    setTimeout(() => {
                        this.dom.memoInput.focus();
                        this.dom.memoInput.setSelectionRange(newText.length, newText.length);
                    }, 0);
                }
            },

            insertTime() {
                const timestamp = this.getFormattedDate();
                const input = this.dom.memoInput;
                const start = input.selectionStart;
                const end = input.selectionEnd;
                const text = input.value;

                const newText = text.substring(0, start) + timestamp + text.substring(end);
                const newCursorPos = start + timestamp.length;

                input.value = newText;
                this.saveData();
                this.updateCharCount();
                
                setTimeout(() => {
                    input.focus();
                    input.setSelectionRange(newCursorPos, newCursorPos);
                }, 0);
            },

            // --- 画像関連処理 ---

            triggerImageSelect() {
                this.dom.imageInput.click();
            },

            handleImageSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.processImageFile(file);
                }
                event.target.value = '';
            },

            handlePaste(event) {
                const items = (event.clipboardData || event.originalEvent.clipboardData).items;
                for (let index in items) {
                    const item = items[index];
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        const blob = item.getAsFile();
                        this.processImageFile(blob);
                    }
                }
            },

            processImageFile(file) {
                if (!file.type.startsWith('image/')) return;
                
                if (file.size > 5 * 1024 * 1024) {
                    alert('画像サイズが大きすぎます（上限5MB）');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    this.setImage(e.target.result);
                    this.saveData();
                };
                reader.readAsDataURL(file);
            },

            setImage(base64String) {
                this.currentImage = base64String;
                this.dom.previewImage.src = base64String;
                this.dom.imagePreviewContainer.classList.remove('hidden');
            },

            removeImage(save = true) {
                this.currentImage = null;
                this.dom.previewImage.src = '';
                this.dom.imagePreviewContainer.classList.add('hidden');
                if (save) this.saveData();
            },

            // --- モーダル関連 ---

            openDeleteModal() {
                if (this.dom.memoInput.value.trim().length === 0 && !this.currentImage) return;
                this.dom.deleteModal.classList.add('active');
            },

            closeDeleteModal() {
                this.dom.deleteModal.classList.remove('active');
            },

            confirmDelete() {
                this.resetWithTimestamp(true);
                this.closeDeleteModal();
            },

            // --- ユーティリティ: Base64 to File ---
            base64ToFile(base64, filename) {
                const arr = base64.split(',');
                const mime = arr[0].match(/:(.*?);/)[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new File([u8arr], filename, { type: mime });
            },

            // --- 共有・コピー ---

            async copyToClipboard() {
                const text = this.dom.memoInput.value;
                const image = this.currentImage;

                try {
                    // 両方ある場合、ClipboardItemで両方書き込みを試みる
                    if (image && text.trim()) {
                        const file = this.base64ToFile(image, 'image.png');
                        const textBlob = new Blob([text], { type: 'text/plain' });
                        
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                [file.type]: file,
                                'text/plain': textBlob
                            })
                        ]);
                    } 
                    // 画像のみ
                    else if (image) {
                        const file = this.base64ToFile(image, 'image.png');
                        await navigator.clipboard.write([
                            new ClipboardItem({ [file.type]: file })
                        ]);
                    }
                    // テキストのみ
                    else if (text.trim()) {
                        await navigator.clipboard.writeText(text);
                    }
                } catch (err) {
                    console.error('Clipboard write failed', err);
                    // フォールバック: テキストのみ
                    if (text.trim()) {
                        try {
                            await navigator.clipboard.writeText(text);
                        } catch (e) {}
                    }
                }
            },

            async shareContent() {
                const text = this.dom.memoInput.value;
                const image = this.currentImage;

                if (!text.trim() && !image) {
                    this.dom.memoInput.focus();
                    return;
                }

                // Web Share APIが使える場合
                if (navigator.share) {
                    try {
                        const shareData = {
                            title: 'Quick Share Memo', // Android等でSubjectになることがある
                            text: text
                        };

                        if (image) {
                            try {
                                // 拡張子をMIMEタイプから推測
                                const mime = image.match(/:(.*?);/)[1];
                                const ext = mime.split('/')[1] || 'png';
                                const file = this.base64ToFile(image, `share_image.${ext}`);
                                const files = [file];

                                // ファイル共有がサポートされているか確認
                                if (navigator.canShare && navigator.canShare({ files })) {
                                    shareData.files = files;
                                }
                            } catch (e) {
                                console.error('Image prep failed', e);
                            }
                        }

                        // 最終的なデータで共有可能かチェック（filesとtextの組み合わせ等）
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                             // 組み合わせがダメなら、ファイル優先で試す（またはテキスト優先）
                             // ここではフォールバックせずエラーとしてcatchブロックへ
                             throw new Error('This share combination is not supported');
                        }

                        await navigator.share(shareData);

                    } catch (err) {
                        console.error('Share failed:', err);
                        // シェア失敗時はクリップボードコピーへフォールバック
                        this.copyToClipboard();
                    }
                } else {
                    this.copyToClipboard();
                }
            }
        };

        // 初期化
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
